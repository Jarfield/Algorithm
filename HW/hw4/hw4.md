## Q1
**解答**
**(a)插入后的红黑树**
```scss
      38(B)
     /    \
   19(R) 41(B)
   /   \
12(B) 31(B)
 /
8(R)
```
**(b)按步骤删除的红黑树**
1. **删除8**
```scss
      38(B)
     /    \
   19(R) 41(B)
   /   \
12(B) 31(B)
```
2. **删除12**
```scss
      38(B)
     /    \
   19(B) 41(B)
     \
    31(R)
```
3. **删除19**
```scss
      38(B)
     /    \
   31(B) 41(B)
```
4. **删除31**
```scss
    38(B)
      \
     41(R)
```
5. **删除38**
```scss
41(B)
```
6. **删除41**
```scss
（空树）
```

## Q2 一棵黑高为 k 的红黑树
**解答**
**1.最小内部结点数**
为了使红黑树的结点尽可能少，即尽量少使用红色结点，同时保证树的黑高是k。
- 所有内部结点都是**黑色**的。
- 这是一个**完全黑色二叉树**，即每个黑色非叶结点都有两个黑色子节点。
- 总结点数为 2^k - 1 。

**2.最大内部结点数**
为了使红黑树的结点尽可能多，即尽量使用红色结点，同时保证树的黑高是k。
- 内部结点交替使用**黑色**和**红色**结点。
- 根结点是**黑色**结点。
- 这是一个**完全二叉树**，实际树高达到 2k 。
- 总结点数为 4^k -1 。

## Q3 区间集合的最大重叠点
**解答**
**(a) 证明：在最大重叠点中，一定存在一个点是其中一个区间的端点。**
**假设**
假设存在一个最大重叠点 P，它不是任何区间的端点。那么，点 P 位于某些区间的内部，即对于这些覆盖点 P 的区间，存在一个小于 P 的开区间和一个大于 P 的开区间。
**构造新点**
对于上述的两个开区间，存在 ε > 0 足够小使得：
- p - ε ，p + ε 位于这些区间内部。
- p - ε ， p + ε 也是最大重叠点。
- p - ε ， p + ε 比 P 跟接近某些区间的端点。
**结论**
重复上述假设和构造过程，直至构造出的新点是某个区间的端点，此时找到同时为某个区间的端点且是最大重叠点的点。

**(b)设计数据结构**
为了支持动态的区间插入和删除，以及查询最大重叠点，我们可以采用**扫描线算法**的思想。
**设计**
1. **事件点**
   - 记录区间的起点和终点的**位置**。
   - 分别用 +1 和 -1 区分起点和终点。
2. **数据结构**
   每个结点存储：
   - key：扫描线当前位置
   - dalta：当前位置覆盖数（起点 +1 ，终点 -1）
   - left：左子树指针
   - right：右子树指针

**操作实现**

**1. INTERVAL-INSERT([a, b])**

**步骤：**

1. **插入起点 $a$：**
- 在树中查找是否存在位置 $a$。
  - **存在**：将节点的 delta 增加 +1。
  - **不存在**：插入一个新节点，key = a，delta = +1。
2. **插入终点 $b$：**
- 在树中查找是否存在位置 $b$。
  - **存在**：将节点的 delta 减少 -1。
  - **不存在**：插入一个新节点，key = b，delta = -1。

**2. INTERVAL-DELETE([a, b])**

**步骤：**

1. **删除起点 $a$：**
- 在树中查找位置 $a$。
  - 将节点的 delta 减少 -1。如果 delta 减为 0，则删除该节点。
2. **删除终点 $b$：**
- 在树中查找位置 $b$。
  - 将节点的 delta 增加 +1。如果 delta 减为 0，则删除该节点。

**3. FIND-POM()**

**步骤：**

   
## Q4